<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
    
<title>
    Decoupling &amp; Communication in Unity
</title>

    <style>
    :root {
        --hash-color: rgb(185, 185, 185);
        --dark-color: #1e1e27;
    }

    html {
        margin: 0;
        padding: 0;
        overflow-x: hidden;
    }

    body {
        background: var(--dark-color);
        padding: 0;
        margin: 0;
        overflow-x: hidden;
    }
    .container {
        font-family: Georgia, "Times New Roman", Times, serif;
        box-sizing: border-box;
    }
    .table-of-contents {
        list-style-type: none;
    }

    .table-of-contents > a {
        display: flex;
        background: #f3f3f3;
        padding: 12pt;
        border-radius: 5px;

        flex-direction: column;
        justify-content: center;
        text-align: center;
        align-items: center;
        margin-bottom: 12pt;
    }

    .table-of-contents > a:hover {
        text-decoration: underline;
    }
    .toc-date {
        font-size: 10pt;
        color: rgb(96, 96, 96);
    }
    .toc {
        margin-top: 4em;
    }
    .table-of-contents > a {
        color: black;
        text-decoration: none;
        font-size: 1.25em;
    }
    .author {
        display: block;
        font-size: 1.15em;
        margin-top: 0.5em;
        text-align: center;
    }
    .main-content {
        line-height: 1.2em;
    }
    .section {
        margin-top: 1em;
        margin-bottom: 1em;
    }
    h2 {
        margin-top: 1.2em;
        margin-bottom: 0;
        font-weight: 500;
    }
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        font-weight: 500;
    }

    h2 {
        font-size: 1.3em;
    }

    h3 {
        font-size: 1.15em;
    }

    h3::before {
        content: "###";
        margin-right: 0.5em;
        color: var(--hash-color);
        font-size: 14pt;
    }

    h4::before {
        content: "####";
        margin-right: 0.5em;
        color: var(--hash-color);
        font-size: 14pt;
    }
    img {
        max-width: 100%;
    }
    h2::before {
        content: "##";
        color: var(--hash-color);
        margin-right: 0.5em;
        font-size: 14pt;
    }
    h1 {
        display: block;
        text-align: center;
        margin-bottom: 0;
        font-weight: 500;
    }
    .subtitle {
        display: block;
        text-align: center;
        color: grey;
        margin: 0;
        font-weight: 200;
        margin-top: 2px;
    }
    .no-indent {
        text-indent: 0;
    }
    p {
        text-indent: 3ex;
        margin: 8pt 0;
    }

    ul.toc {
        text-indent: 0;
        padding: 0;
    }

    .main-blog-link {
        margin-top: 2em;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .container {
        background: white;
        padding: 4em 2em;
        margin-left: auto;
        margin-right: auto;
        max-width: 750px;
        margin-top: 50px;
        box-shadow: 0 0 15px black;
        box-sizing: border-box;
    }

    nav {
        display: flex;
        height: 1.5em;
        justify-content: center;
        align-items: center;
        left: 0;
        top: 0;
        width: 100%;
        background: var(--dark-color);
        position: fixed;
        padding: 5px;
    }
    nav > a {
        text-decoration: none;
        color: white;
        font-weight: bold;
        font-family: cursive;
    }

    nav > a:hover {
        text-decoration: underline;
    }

    .no-decor {
        text-decoration: none;
    }

    .fg-black {
        color: black;
    }

    pre {
        overflow-x: scroll;
    }
    p {
        margin: 13x 0;
    }
    p > code {
        background: #f3f3f3;
        padding: 0 0.5ex;
        border-radius: 0.5ex;
    }
    pre {
        padding: 0.5em;
        border-radius: 10px;
        tab-size: 5ex;
    }
    @media print {
        html,
        body {
            background: white;
        }
        .container {
            width: 100%;
            margin: 0;
            padding: 0;
            box-shadow: none;
        }
        nav {
            display: none;
        }
    }
</style>

</head>

<body>
    <nav>
        <a href="https://andystopia.github.io/blog/cs/">Home</a>
    </nav>
  <section class="section">
    <div class="container">
      
<h1 class="title no-indent">
  Decoupling &amp; Communication in Unity
</h1>
<p class="author no-indent">
    @andystopia
</p>
<p class="subtitle no-indent">
    2023-01-29
</p>
<div class="main-content">
<h2 id="background">Background</h2>
<p>As a bit of a disclaimer, I don't do a lot of game dev myself, and am mostly leaving this here as a guide to my future self so that I don't forget.</p>
<p>What is decoupling? It is essentially the procedure of separating implementation from behavior. It is the process of abstraction. </p>
<p>I could explain more, but let's dive into an example.</p>
<p>Let's say that we have a game, where players and enemies have an <code>Inventory</code> and there's things on the ground that can be picked up.</p>
<p>We could of course, for every object that could be picked up, model a way for that object to be picked up individually, but this is tedious and sacrifices time without even the benefit of flexibility. </p>
<p>So let's do something else instead. </p>
<p>Let's say that when our player collides with our pickable, they try to place it in their inventory. </p>
<p>To do this, let's think about what actions need to be performed. </p>
<p>Unity already gives us <code>OnCollideEnter</code>, for free, so let's just use that and when we collide, we can see if there's a component that's pickable on the item. That's the basic premise, but how do we know that an object is pickable, without <em>constraining</em> how we write code at all. </p>
<p>To do this, we can write what's called an interface. An interface defines what behaviors/methods are required to be implemented for a class to fully satisfy a certain behavior.  A class can later implement interfaces (like class extension, but the methods must be implemented entirely not overridden).</p>
<pre data-lang="cs" style="background-color:#fafafa;color:#383a42;" class="language-cs "><code class="language-cs" data-lang="cs"><span style="color:#a626a4;">interface </span><span>IPickable { 
</span><span>	</span><span style="color:#a0a1a7;">/**
</span><span style="color:#a0a1a7;">	* Creates / shows the game object in the scene
</span><span style="color:#a0a1a7;">	* 
</span><span style="color:#a0a1a7;">	* @param position the position to place the pickable
</span><span style="color:#a0a1a7;">	* @returns a game object that could be picked up later
</span><span style="color:#a0a1a7;">	*/
</span><span>	GameObject </span><span style="color:#0184bc;">drop</span><span>(Vector3 </span><span style="color:#e45649;">position</span><span>);
</span><span>
</span><span>	</span><span style="color:#a0a1a7;">/**
</span><span style="color:#a0a1a7;">	 * Hides / deletes the game object from the scene
</span><span style="color:#a0a1a7;">	 */
</span><span>	</span><span style="color:#a626a4;">void </span><span style="color:#0184bc;">pickup</span><span>();
</span><span>}
</span></code></pre>
<p>Note the &quot;I&quot; in front of <code>IPickable</code>. This is just by convention, C# devs generally write the letter &quot;I&quot; in front of the name of any interface. That convention is adopted here.</p>
<p>As an example of away to fulfill this behavior, but not the only way, it would be possible to use a prefab and <code>Instantiate</code> prefabs places, removing them or hiding them when they are picked up, but the actual mechanism doesn't matter. </p>
<p>Note that for most games, pickup probably shouldn't be <code>void</code>, but rather some other interface or base class (probably some extension of <code>ScriptableObject</code>), this provides a way to display them in the inventory. <a href="https://www.youtube.com/watch?v=aPXvoWVabPY">Brakey's</a> has a great, relevant video on <code>ScriptableObject</code>s, that could probably contextualize this.</p>
<p>Depending on our use case, our inventory class can essentially be a <code>List&lt;IPickable?&gt;</code> (prefilled with null where useful), or it can can be a <code>List</code> of whatever the pickup method returns. Either way could certainly work, and it just simply depends on implementation requirements.</p>
<p>For our player collision method, we'd want at least the following code:</p>
<pre data-lang="cs" style="background-color:#fafafa;color:#383a42;" class="language-cs "><code class="language-cs" data-lang="cs"><span style="color:#a626a4;">void </span><span style="color:#0184bc;">OnCollisionEnter</span><span>(Collision </span><span style="color:#e45649;">collision</span><span>) { 
</span><span>	</span><span style="color:#a626a4;">var </span><span style="color:#e45649;">pickable </span><span style="color:#a626a4;">= </span><span style="color:#e45649;">TryGetComponent</span><span>&lt;IPickable&gt;(</span><span style="color:#e45649;">collision</span><span>.</span><span style="color:#e45649;">gameObject</span><span>);
</span><span>	</span><span style="color:#a626a4;">if </span><span>(</span><span style="color:#e45649;">pickable </span><span style="color:#a626a4;">!= </span><span style="color:#c18401;">null</span><span>) {
</span><span>		</span><span style="color:#e45649;">pickable</span><span>.</span><span style="color:#e45649;">pickup</span><span>();
</span><span>	}
</span><span>}
</span></code></pre>
<p>That will pick up our component, however, you will probably want to do do some sort of 1. <code>inventory.InsertPickable(pickable)</code>, <em>or</em>, 2. <code>inventory.PickedUp(pickable.pickup())</code>, depending on what the design requires. 2 will probably be used for most games moreso than 1.</p>
<p>For pickable, we could simply define a component for the most general case, with no special behaviors</p>
<pre data-lang="cs" style="background-color:#fafafa;color:#383a42;" class="language-cs "><code class="language-cs" data-lang="cs"><span style="color:#a626a4;">class </span><span style="color:#c18401;">Pickable: MonoBehavior, IPickable { 
</span><span style="color:#c18401;">	</span><span style="color:#a0a1a7;">/**
</span><span style="color:#a0a1a7;">	* Creates / shows the game object in the scene
</span><span style="color:#a0a1a7;">	* 
</span><span style="color:#a0a1a7;">	* @param position the position to place the pickable
</span><span style="color:#a0a1a7;">	* @returns a game object that could be picked up later
</span><span style="color:#a0a1a7;">	*/
</span><span style="color:#c18401;">	GameObject </span><span style="color:#0184bc;">drop</span><span style="color:#c18401;">(Vector3 </span><span style="color:#e45649;">position</span><span style="color:#c18401;">) { 
</span><span style="color:#c18401;">		</span><span style="color:#a0a1a7;">// instantiate a new prefab at vector3 position
</span><span style="color:#c18401;">		</span><span style="color:#e45649;">this</span><span style="color:#c18401;">.</span><span style="color:#e45649;">transform</span><span style="color:#c18401;">.</span><span style="color:#e45649;">position </span><span style="color:#a626a4;">= </span><span style="color:#e45649;">position</span><span style="color:#c18401;">;
</span><span style="color:#c18401;">		</span><span style="color:#e45649;">SetActive</span><span style="color:#c18401;">(true);
</span><span style="color:#c18401;">	}
</span><span style="color:#c18401;">
</span><span style="color:#c18401;">	</span><span style="color:#a0a1a7;">/**
</span><span style="color:#a0a1a7;">	 * Hides / deletes the game object from the scene
</span><span style="color:#a0a1a7;">	 */
</span><span style="color:#c18401;">	</span><span style="color:#a626a4;">void </span><span style="color:#0184bc;">pickup</span><span style="color:#c18401;">() { 
</span><span style="color:#c18401;">		</span><span style="color:#e45649;">SetActive</span><span style="color:#c18401;">(false);
</span><span style="color:#c18401;">	}
</span><span style="color:#c18401;">}
</span></code></pre>
<p>Now we can add the Pickable to any prefab that we would like by dragging it and dropping it in the Unity Scene Editor, and that will make it so player could collect that prefab instance and also drop it. Hopefully that last sentence carries a little weight, because it means we can essentially just mark prefabs as pickable in the Unity Scene Editor, without any changes to the codebase. If we want <em>special behavior</em> for some other prefab, we don't need to special case it in here. We can write a new class, similar to this one, but change out the body of the methods with the behavior we want, and not have to change anything about the code, and that <code>MonoBehavior</code> could be dropped onto any prefab. The player collision code cares that our class implements <code>IPickable</code> not <code>Pickable</code>, so we aren't dependent on the last code block at all. Once you're comfortable with this style, you could easily write, without any if statements, other behaviors such as pickables that never run out, pickables that can be picked up 3 times, etc. Having all your changes be additive makes it easy for other programmers to come along, and implement a new pickable, they don't need to understand how you wrote your code, they just need to implement the interface.</p>
<p>Whew! That was a heck of a background. We did gloss over a few aspects though, which are much harder, communication. Where did our inventory come from? How do we re-use the inventory code for enemies and players? How do we access it? What if Unity didn't provide us with something like <code>OnCollisionEnter</code> or <code>TryGetComponent</code>? What if we want a cutscene to play when we pick up a specific pickable? This was my biggest stumbling block in Unity: communication.</p>
<h2 id="why-communicate">Why Communicate?</h2>
<p>We can certainly just request the type of the object that we want as a serialized field in our classes and invoke methods on that. Why shouldn't we do that? </p>
<ol>
<li>Sometimes it's okay, <em>but</em> most times, it <em>isn't</em>. However, if it's one simple thing that will probably not need to be changed, I wouldn't bother.</li>
<li>Lack of Flexibility. Let's say I start a game and I as a <code>Player</code> has a <code>Dog</code> instance in a serialize field and I can pet that dog for a slight happiness buff. Let's say later on, I want a cat instead, now it's time to refactor. I don't like refactoring, because it requires refactoring + whatever else I wanted to be doing.</li>
<li>Doesn't fit all use cases: Let's say my player could freeze bullets midair. Let's say there was a <em>lot</em> of bullets in the game. Now my player needs to hold a <code>List&lt;Bullet&gt;</code> and update that list depending on what bullets are in the scene. Also I need to iterate over them, whenever I freeze time. This is a repetitive pattern and annoying to get right. Oh wait, I actually want to freeze plasma rays too!</li>
<li>No official support for interfaces. Everything will be constrained by some base class. A base class  <code>Pettable</code> is restrictive for the <code>Dog</code> example, because our <code>Dog</code> might also extend something like <code>Mammal</code>, and not all <code>Mammal</code>s are <code>Pettable</code>, but we can't extend both <code>Mammal</code> and <code>Pettable</code>.</li>
</ol>
<p>Often times, other communication patterns simply fit better, and allow us to &quot;lift up&quot; more game design choices into Unity Scene Editor itself, where non-programmers can make changes</p>
<h2 id="same-object-communication">Same Object Communication</h2>
<p>Perhaps the simplest form of communication, simply one component talking to other components on the same game object.</p>
<p>While it is possible to implement most entity behaviors using simply one monobehavior, this is often inflexible, and can lead to classes that take a lot to understand because they implement a lot of distinct pieces of logic. There is a concept called the <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Single Responsibility Principle</a>. Every class implemented would be preferably implemented to this standard, and when possible, it should be adhered to. </p>
<p>Separating out game logic into different components promotes re-use and makes reading code and implementing new features a little easier. To communicate between components, define interfaces between them for communication, that way, it's simple to change out one component for another.</p>
<p>For instance our main character entity could have </p>
<ul>
<li><code>Player</code></li>
<li><code>Inventory</code></li>
</ul>
<p>Let's say our player class facilites movement and picking things up. What we probably want for our inventory is an IPlayerInventory interface, which Inventory can implement. This allows us to substitute out our inventories if we should want to do something like that in the future. We can always request components by an interface they implement by calling <code>GetComponent&lt;IPlayerInventory&gt;</code>. Our IPlayerInventory should at least probably support adding and dropping pickables, as well as perhaps some way to request all the items in the inventory so we can display them required as methods.</p>
<p>As an example, we could have an an interface,</p>
<pre data-lang="cs" style="background-color:#fafafa;color:#383a42;" class="language-cs "><code class="language-cs" data-lang="cs"><span style="color:#a626a4;">interface </span><span>IPlayerInventory&lt;T&gt; { 
</span><span>	IEnumerable&lt;T&gt; </span><span style="color:#0184bc;">RetrieveItems</span><span>();
</span><span>	</span><span style="color:#a626a4;">void </span><span style="color:#0184bc;">Pickup</span><span>(T </span><span style="color:#e45649;">pickable</span><span>);
</span><span>	</span><span style="color:#a626a4;">void </span><span style="color:#0184bc;">Drop</span><span>(T </span><span style="color:#e45649;">pickable</span><span>);
</span><span>}
</span></code></pre>
<p>Note that from the case discussed in the background <code>IPickable</code> is the type that satisfies T for an inventory containing pickables. </p>
<p>Now in our <code>Player:  MonoBehaviour</code></p>
<pre data-lang="cs" style="background-color:#fafafa;color:#383a42;" class="language-cs "><code class="language-cs" data-lang="cs"><span style="color:#a626a4;">class </span><span style="color:#c18401;">Player: MonoBehaviour {
</span><span style="color:#c18401;">	</span><span style="color:#a626a4;">private </span><span style="color:#c18401;">IPlayerInventory&lt;IPickable&gt; </span><span style="color:#e45649;">inventory</span><span style="color:#c18401;">;
</span><span style="color:#c18401;">	</span><span style="color:#a626a4;">void </span><span style="color:#0184bc;">Awake</span><span style="color:#c18401;">() { 
</span><span style="color:#c18401;">		</span><span style="color:#e45649;">inventory </span><span style="color:#a626a4;">= </span><span style="color:#e45649;">GetComponent</span><span style="color:#c18401;">&lt;IPlayerInventory&lt;IPickable&gt;&gt;();
</span><span style="color:#c18401;">	}
</span><span style="color:#c18401;">
</span><span style="color:#c18401;">	</span><span style="color:#a626a4;">void </span><span style="color:#0184bc;">OnCollisionEnter</span><span style="color:#c18401;">(Collision </span><span style="color:#e45649;">collision</span><span style="color:#c18401;">) { 
</span><span style="color:#c18401;">		</span><span style="color:#a626a4;">var </span><span style="color:#e45649;">pickable </span><span style="color:#a626a4;">= </span><span style="color:#e45649;">TryGetComponent</span><span style="color:#c18401;">&lt;IPickable&gt;(</span><span style="color:#e45649;">collision</span><span style="color:#c18401;">.</span><span style="color:#e45649;">gameObject</span><span style="color:#c18401;">);
</span><span style="color:#c18401;">		</span><span style="color:#a626a4;">if </span><span style="color:#c18401;">(</span><span style="color:#e45649;">pickable </span><span style="color:#a626a4;">!= </span><span style="color:#c18401;">null) {
</span><span style="color:#c18401;">			</span><span style="color:#e45649;">pickable</span><span style="color:#c18401;">.</span><span style="color:#e45649;">pickup</span><span style="color:#c18401;">();
</span><span style="color:#c18401;">			</span><span style="color:#e45649;">inventory</span><span style="color:#c18401;">.</span><span style="color:#e45649;">Pickup</span><span style="color:#c18401;">(</span><span style="color:#e45649;">pickable</span><span style="color:#c18401;">);
</span><span style="color:#c18401;">		}
</span><span style="color:#c18401;">	}
</span><span style="color:#c18401;">}
</span></code></pre>
<p>Note that in this case, we can clearly see that the player doesn't require a specific inventory, it just requires one that meets the bounds required above. We can then implement an inventory that adheres to the <code>IPlayerInterface&lt;IPickable&gt;</code>. This style of coding clearly establishes a separation of concerns. </p>
<p>Hopefully at this point, it is clear how we could swap out other implementations for inventory. </p>
<p>Note that this subsection's description is often referred to as the <code>Strategy</code> pattern. </p>
<h2 id="peer-to-peer-driven-communication">Peer to Peer Driven Communication</h2>
<p>The ability for one object to reflect the state of another object, such as a hotbar reflecting an inventory is often a necessary feature for games to implement. </p>
<p>As of right now, I would probably just have a hotbar component that receives an <code>[SerializeField] private Inventory inventory</code> instance and calls it's public methods directly, but if you know a good way to decouple these behaviors without using an external package, please PR!</p>
<p>Update: 2023-2-2</p>
<p>While I haven't tried this, given a little more thought about this use case, perhaps something like the <a href="https://developer.mozilla.org/en-US/docs/Glossary/MVC">Model View Controller</a> would be most sufficient. </p>
<p><img src="https://developer.mozilla.org/en-US/docs/Glossary/MVC/model-view-controller-light-blue.png" alt="" /></p>
<p>This is a well established pattern, so perhaps we can think about how we can apply it to Unity. Let's think about an Inventory reflected in a &quot;hotbar&quot; kind of scenario. The &quot;inventory&quot; is the Model in the model view controller. </p>
<p>Let's think of the design for the hotbar. There could be a hotbar game object, which shows the user the hotbar, in model view controller this would be our <code>View</code>. An instance attached like <code>InventoryHotbarViewUI</code> is a possible name for one of the hotbar components. Then something like <code>InventoryHotbarViewController</code> could be attached to the original element and this could communicate to the <code>Inventory</code> (Model) through the same pattern as &quot;Same Object Communication&quot;. The view accepts the controller directly, in that way, the components are tightly coupled, but I think that for most cases the view <em>is</em> intrinsically tied to the controller. However it makes sense that the controller shouldn't be intrinsically linked to the inventory (but should rather talk to it through the Strategy pattern as outlined in the &quot;Same Object Communication&quot; section).  The interface that the <code>Inventory</code> talks to the controllers through should capture the behavior of the inventory with the most lax type bounds possible. </p>
<p>For the full inventory edit menu (like something that takes up the whole screen), a similar treatment is applied. A View is applied to an external element and a controller is added as a component to the <code>Inventory</code> game object. Use the unity editor to supply the field on the view which takes the <code>Controller</code> instance by type directly. </p>
<p>Note it is <em>crucial</em> that the inventory supplies objects by reference, not by value through it's implementing interface, so that the child components can just re-render that on every frame. This is slightly inefficient, but the alternative would be to wire up some &quot;peer-to-peer&quot; messaging that tells the objects when to poll for new value types. A large part benefit of this pattern comes from the fact that the inventory is the one source of truth, it and it alone manages the state, so there's nothing to sync up between game objects.</p>
<p>The benefits of this pattern, though slightly more boilerplate, is that it's possible to change implementations for the Inventory, <em>but</em> not break the views or editing logic of dependents. It is also possible to swap out multiple ways to work with the inventory without having to modify the inventory itself. </p>
<p>Of course the downside is that we need to hand roll a new controller every time, but I have a feeling this pattern doesn't come up so often that it is a killer.</p>
<h2 id="multiple-producer-multiple-consumer-communication">Multiple-Producer, Multiple-Consumer Communication</h2>
<h3 id="definitions">Definitions</h3>
<p>I invented the terms &quot;restrictive&quot; and &quot;unrestrictive&quot; to describe modes of event sending where communication is limited to those who have an instance of a certain event channel (former), and event systems where just broad listening is possible &quot;unrestrictive&quot;.</p>
<p>&quot;peer&quot; here refers to &quot;<code>GameObject</code>s&quot;.</p>
<h3 id="restrictive-events">Restrictive Events</h3>
<p>The essential premise is what I've heard other Unity devs online call the &quot;<code>ScriptableObject</code> Channel&quot;, where scriptable object instances made in Unity are provided to Unity <code>MonoBehaviours</code>, and then messages are passed through the channel where listeners react to those events. </p>
<p>There are two kinds of these as well, lazy and sequential. Pull from queue to know what's available(lazy), and react to events the moment they happen(sequential). </p>
<p>So for instance, I could have an <code>InventoryUpdateChannel</code> called <code>invChannel</code> and I can say <code>invChannel.publish(new InventoryUpdate(7, potatoes))</code>. When &quot;potatoes&quot; are  in slot 7, and a listener can pick this up and can then update the hotbar.</p>
<p>Here's how the approach breaks down, </p>
<ul>
<li>In the GUI
<ul>
<li>Create instance of message channel scriptable object for any specific channel type</li>
<li>Pass instance to receiving <code>MonoBehaviours</code></li>
</ul>
</li>
<li>In the code
<ul>
<li>Receive instance of channel (1 line)</li>
<li>Publish events (1 line)</li>
<li>Subscript events (1 line)</li>
</ul>
</li>
</ul>
<p>This is in contrast to method calling directly calling one peer method (1 line for method call + 1 line one serialize field or worse <code>FindObjectOfType</code> = 2 lines), or if many things need to be called, it will add an additional two lines, either every time, or inside a method (now 5 lines). The channel based approach is more flexible to use in the editor, is more flexible to implement, and is shorter than method calls directly, if there are multiple listeners, but does come at a slight performance hit.</p>
<p>A simple way to do event based peer to peer messaging would be to follow an implementation like my own, <a href="https://github.com/andystopia/RadioActive">RadioActive</a>. It is sequential. It is possible to use as is, or as inspiration to write a different system. It keeps concerns separate across messaging channels and takes decent advantage of the C# type system.</p>
<h3 id="unrestrictive-events">Unrestrictive Events</h3>
<p>Sometimes, it's desirable be able to fire off, arbitrary events with perhaps a few instances associated with that, there is a package called <a href="https://github.com/prime31/MessageKit">MessageKit</a>. I haven't used it myself, but for most things I would argue that it is a better fit than many other solutions posted here for simpler projects. For more complex projects, longer stories, more elements, etc, I have a feeling this package will feel quite limited and would recommend writing something using <code>ScriptableObject</code>s</p>

</div>

    </div>
  </section>
  
</body>

</html>